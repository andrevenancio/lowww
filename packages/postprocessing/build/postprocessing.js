(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = global || self, factory((global.lowww = global.lowww || {}, global.lowww.postprocessing = {})));
}(this, function (exports) { 'use strict';

    var Horizontal = {
        uniforms: {
            u_input: { type: 'sampler2D', value: null },
            u_amount: { type: 'float', value: 512 }
        },

        vertex: '\n    out vec2 v_uv;\n    void main() {\n        gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(a_position, 1.0);\n        v_uv = a_uv;\n    }',

        fragment: '\n    in vec2 v_uv;\n\n    uniform sampler2D u_input;\n    uniform float u_amount;\n\n    void main() {\n        vec4 sum = vec4(0.0);\n        float hh = (1.0 / u_amount);\n\n        sum += texture(u_input, vec2(v_uv.x - 4.0 * hh, v_uv.y)) * 0.051;\n        sum += texture(u_input, vec2(v_uv.x - 3.0 * hh, v_uv.y)) * 0.0918;\n        sum += texture(u_input, vec2(v_uv.x - 2.0 * hh, v_uv.y)) * 0.12245;\n        sum += texture(u_input, vec2(v_uv.x - 1.0 * hh, v_uv.y)) * 0.1531;\n        sum += texture(u_input, vec2(v_uv.x, v_uv.y ) ) * 0.1633;\n        sum += texture(u_input, vec2(v_uv.x + 1.0 * hh, v_uv.y)) * 0.1531;\n        sum += texture(u_input, vec2(v_uv.x + 2.0 * hh, v_uv.y)) * 0.12245;\n        sum += texture(u_input, vec2(v_uv.x + 3.0 * hh, v_uv.y)) * 0.0918;\n        sum += texture(u_input, vec2(v_uv.x + 4.0 * hh, v_uv.y)) * 0.051;\n\n        outColor = sum;\n    }'
    };

    var Vertical = {
        uniforms: {
            u_input: { type: 'sampler2D', value: null },
            u_amount: { type: 'float', value: 512 }
        },

        vertex: '\n    out vec2 v_uv;\n    void main() {\n        gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(a_position, 1.0);\n        v_uv = a_uv;\n    }',

        fragment: '\n    in vec2 v_uv;\n\n    uniform sampler2D u_input;\n    uniform float u_amount;\n\n    void main() {\n        vec4 sum = vec4(0.0);\n        float vv = (1.0 / u_amount);\n\n        sum += texture(u_input, vec2(v_uv.x, v_uv.y - 4.0 * vv)) * 0.051;\n        sum += texture(u_input, vec2(v_uv.x, v_uv.y - 3.0 * vv)) * 0.0918;\n        sum += texture(u_input, vec2(v_uv.x, v_uv.y - 2.0 * vv)) * 0.12245;\n        sum += texture(u_input, vec2(v_uv.x, v_uv.y - 1.0 * vv)) * 0.1531;\n        sum += texture(u_input, vec2(v_uv.x, v_uv.y ) ) * 0.1633;\n        sum += texture(u_input, vec2(v_uv.x, v_uv.y + 1.0 * vv)) * 0.1531;\n        sum += texture(u_input, vec2(v_uv.x, v_uv.y + 2.0 * vv)) * 0.12245;\n        sum += texture(u_input, vec2(v_uv.x, v_uv.y + 3.0 * vv)) * 0.0918;\n        sum += texture(u_input, vec2(v_uv.x, v_uv.y + 4.0 * vv)) * 0.051;\n\n        outColor = sum;\n    }'
    };



    var index = /*#__PURE__*/Object.freeze({
        Horizontal: Horizontal,
        Vertical: Vertical
    });

    var Bleach = {
        uniforms: {
            u_input: { type: 'sampler2D', value: null },
            u_opacity: { type: 'float', value: 1.0 }
        },

        vertex: '\n    out vec2 v_uv;\n    void main() {\n        gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(a_position, 1.0);\n        v_uv = a_uv;\n    }',

        fragment: '\n    in vec2 v_uv;\n\n    uniform sampler2D u_input;\n    uniform float u_opacity;\n\n    void main() {\n\n        vec4 base = texture(u_input, v_uv);\n\n        vec3 lumCoeff = vec3(0.25, 0.65, 0.1);\n        float lum = dot(lumCoeff, base.rgb);\n        vec3 blend = vec3(lum);\n\n        float L = min(1.0, max(0.0, 10.0 * (lum - 0.45)));\n\n        vec3 result1 = 2.0 * base.rgb * blend;\n        vec3 result2 = 1.0 - 2.0 * (1.0 - blend) * (1.0 - base.rgb);\n\n        vec3 newColor = mix(result1, result2, L);\n\n        float A2 = u_opacity * base.a;\n        vec3 mixRGB = A2 * newColor.rgb;\n        mixRGB += ((1.0 - A2) * base.rgb);\n\n        outColor = vec4(mixRGB, base.a);\n    }'
    };

    var Brightness = {
        uniforms: {
            u_input: { type: 'sampler2D', value: null },
            u_treshold: { type: 'float', value: 0.0 }
        },

        vertex: '\n    out vec2 v_uv;\n    void main() {\n        gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(a_position, 1.0);\n        v_uv = a_uv;\n    }',

        fragment: '\n    in vec2 v_uv;\n\n    uniform sampler2D u_input;\n    uniform float u_treshold;\n\n    void main() {\n        // relative luminance\n        vec3 lum = vec3(0.2126, 0.7152, 0.0722);\n        vec4 c = texture(u_input, v_uv);\n\n        float luminance = dot(lum, c.xyz);\n        luminance = max(0.0, luminance - u_treshold);\n        c.xyz *= sign(luminance);\n        c.a = 1.0;\n\n        outColor = c;\n    }'
    };

    var DotScreen = {
        uniforms: {
            u_input: { type: 'sampler2D', value: null },
            u_size: { type: 'float', value: 256 },
            u_center: { type: 'vec2', value: [0.5, 0.5] },
            u_angle: { type: 'float', value: 1.57 },
            u_scale: { type: 'float', value: 1.0 }
        },

        vertex: '\n    out vec2 v_uv;\n    void main() {\n        gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(a_position, 1.0);\n        v_uv = a_uv;\n    }',

        fragment: '\n    in vec2 v_uv;\n\n    uniform sampler2D u_input;\n\n    uniform vec2 u_center;\n    uniform float u_angle;\n    uniform float u_scale;\n    uniform float u_size;\n\n    float pattern() {\n        float s = sin(u_angle), c = cos(u_angle);\n\n        vec2 tex = v_uv * vec2(u_size) - u_center;\n        vec2 point = vec2(c * tex.x - s * tex.y, s * tex.x + c * tex.y) * u_scale;\n\n        return (sin(point.x) * sin(point.y)) * 4.0;\n    }\n\n    void main() {\n        vec4 color = texture(u_input, v_uv);\n\n        float average = (color.r + color.g + color.b) / 3.0;\n\n        outColor = vec4(vec3(average * 10.0 - 5.0 + pattern()), color.a);\n    }'
    };

    var Horizontal$1 = {
        uniforms: {
            u_input: { type: 'sampler2D', value: null },
            u_amount: { type: 'float', value: 128 },
            u_xscreenpos: { type: 'float', value: 0.5 }
        },

        vertex: '\n    out vec2 v_uv;\n    void main() {\n        gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(a_position, 1.0);\n        v_uv = a_uv;\n    }',

        fragment: '\n    in vec2 v_uv;\n\n    uniform sampler2D u_input;\n    uniform float u_amount;\n    uniform float u_xscreenpos;\n\n    void main() {\n        vec4 sum = vec4(0.0);\n        float hh = (1.0 / u_amount) * abs(u_xscreenpos - v_uv.x);\n\n        sum += texture(u_input, vec2(v_uv.x - 4.0 * hh, v_uv.y)) * 0.051;\n        sum += texture(u_input, vec2(v_uv.x - 3.0 * hh, v_uv.y)) * 0.0918;\n        sum += texture(u_input, vec2(v_uv.x - 2.0 * hh, v_uv.y)) * 0.12245;\n        sum += texture(u_input, vec2(v_uv.x - 1.0 * hh, v_uv.y)) * 0.1531;\n        sum += texture(u_input, vec2(v_uv.x, v_uv.y ) ) * 0.1633;\n        sum += texture(u_input, vec2(v_uv.x + 1.0 * hh, v_uv.y)) * 0.1531;\n        sum += texture(u_input, vec2(v_uv.x + 2.0 * hh, v_uv.y)) * 0.12245;\n        sum += texture(u_input, vec2(v_uv.x + 3.0 * hh, v_uv.y)) * 0.0918;\n        sum += texture(u_input, vec2(v_uv.x + 4.0 * hh, v_uv.y)) * 0.051;\n\n        outColor = sum;\n    }'
    };

    var Vertical$1 = {
        uniforms: {
            u_input: { type: 'sampler2D', value: null },
            u_amount: { type: 'float', value: 128 },
            u_yscreenpos: { type: 'float', value: 0.5 }
        },

        vertex: '\n    out vec2 v_uv;\n    void main() {\n        gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(a_position, 1.0);\n        v_uv = a_uv;\n    }',

        fragment: '\n    in vec2 v_uv;\n\n    uniform sampler2D u_input;\n    uniform float u_amount;\n    uniform float u_yscreenpos;\n\n    void main() {\n        vec4 sum = vec4(0.0);\n        float vv = (1.0 / u_amount) * abs(u_yscreenpos - v_uv.y);\n\n        sum += texture(u_input, vec2(v_uv.x, v_uv.y - 4.0 * vv)) * 0.051;\n        sum += texture(u_input, vec2(v_uv.x, v_uv.y - 3.0 * vv)) * 0.0918;\n        sum += texture(u_input, vec2(v_uv.x, v_uv.y - 2.0 * vv)) * 0.12245;\n        sum += texture(u_input, vec2(v_uv.x, v_uv.y - 1.0 * vv)) * 0.1531;\n        sum += texture(u_input, vec2(v_uv.x, v_uv.y ) ) * 0.1633;\n        sum += texture(u_input, vec2(v_uv.x, v_uv.y + 1.0 * vv)) * 0.1531;\n        sum += texture(u_input, vec2(v_uv.x, v_uv.y + 2.0 * vv)) * 0.12245;\n        sum += texture(u_input, vec2(v_uv.x, v_uv.y + 3.0 * vv)) * 0.0918;\n        sum += texture(u_input, vec2(v_uv.x, v_uv.y + 4.0 * vv)) * 0.051;\n\n        outColor = sum;\n    }'
    };



    var index$1 = /*#__PURE__*/Object.freeze({
        Horizontal: Horizontal$1,
        Vertical: Vertical$1
    });

    var Noise = {
        uniforms: {
            u_input: { type: 'sampler2D', value: null },
            u_seed: { type: 'float', value: 0.01 },
            u_amount: { type: 'float', value: 0.5 }
        },

        vertex: '\n    out vec2 v_uv;\n    void main() {\n        gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(a_position, 1.0);\n        v_uv = a_uv;\n    }',

        fragment: '\n    in vec2 v_uv;\n\n    uniform sampler2D u_input;\n    uniform float u_seed;\n    uniform float u_amount;\n\n    float rand(vec2 uv) {\n        return fract(sin(dot(uv.xy, vec2(12.9898, 78.233))) * 43758.5453);\n    }\n\n    void main() {\n        vec4 color = texture(u_input, v_uv);\n        float random = rand(gl_FragCoord.xy * u_seed);\n        float diff = (random - 0.5) * u_amount;\n\n        color.r += diff;\n        color.g += diff;\n        color.b += diff;\n\n        outColor = color;\n    }'
    };

    var HueSaturation = {
        uniforms: {
            u_input: { type: 'sampler2D', value: null },
            u_hue: { type: 'float', value: 0.0 }, // -1 to 1
            u_saturation: { type: 'float', value: 0.0 } // -1 to 1
        },

        vertex: '\n    out vec2 v_uv;\n    void main() {\n        gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(a_position, 1.0);\n        v_uv = a_uv;\n    }',

        fragment: '\n    in vec2 v_uv;\n\n    uniform sampler2D u_input;\n    uniform float u_hue;\n    uniform float u_saturation;\n\n    void main() {\n        vec4 color = texture(u_input, v_uv);\n        float angle = u_hue * 3.14159265;\n        float s = sin(angle), c = cos(angle);\n        vec3 weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;\n        float len = length(color.rgb);\n        color.rgb = vec3(\n            dot(color.rgb, weights.xyz),\n            dot(color.rgb, weights.zxy),\n            dot(color.rgb, weights.yzx)\n        );\n\n        float average = (color.r + color.g + color.b) / 3.0;\n        if (u_saturation > 0.0) {\n            color.rgb += (average - color.rgb) * (1.0 - 1.0 / (1.001 - u_saturation));\n        } else {\n            color.rgb += (average - color.rgb) * (-u_saturation);\n        }\n\n        outColor = color;\n    }'
    };

    // inspired by: https://www.shadertoy.com/view/4t23Rc
    var Glitch = {
        uniforms: {
            u_input: { type: 'sampler2D', value: null },
            u_amplitude: { type: 'float', value: 3.0 },
            u_speed: { type: 'float', value: 2.0 }
        },

        vertex: '\n    out vec2 v_uv;\n    void main() {\n        gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(a_position, 1.0);\n        v_uv = a_uv;\n    }',

        fragment: '\n    in vec2 v_uv;\n\n    uniform sampler2D u_input;\n    uniform float u_speed;\n    uniform float u_amplitude;\n\n    vec4 rgbShift(vec2 p, vec4 shift) {\n        shift *= 2.0 * shift.w - 1.0;\n        vec2 rs = vec2(shift.x, -shift.y);\n        vec2 gs = vec2(shift.y, -shift.z);\n        vec2 bs = vec2(shift.z, -shift.x);\n\n        float r = texture(u_input, p + rs).x;\n        float g = texture(u_input, p + gs).y;\n        float b = texture(u_input, p + bs).z;\n\n        return vec4(r, g, b, 1.0);\n    }\n\n    float rand(vec2 uv) {\n        return fract(sin(dot(uv.xy, vec2(12.9898, 78.233))) * 43758.5453);\n    }\n\n    vec4 noise(vec2 n) {\n        float r = rand(n.xy + 0.1);\n        float g = rand(n.xy + 0.2);\n        float b = rand(n.xy + 0.3);\n        return vec4(r - 0.5, g - 0.5, b - 0.5, 1.0);\n    }\n\n    vec4 vec4pow(vec4 v, float p) {\n        return vec4(pow(v.x, p), pow(v.y, p), pow(v.z, p), v.w);\n    }\n\n    void main() {\n        vec4 color = texture(u_input, v_uv);\n\n        vec4 c = vec4(0.0, 0.0, 0.0, 1.0);\n\n        float v = clamp(sin(iGlobalTime * u_speed), 0.0, 1.0);\n        vec4 shift = vec4pow(noise(vec2(1.0 - v, 0.0)), 8.0) * vec4(u_amplitude, u_amplitude, u_amplitude, 1.0) * v;\n\n        c += rgbShift(v_uv, shift);\n\n        outColor = c;\n    }'
    };

    exports.Bleach = Bleach;
    exports.Brightness = Brightness;
    exports.DotScreen = DotScreen;
    exports.Glitch = Glitch;
    exports.HueSaturation = HueSaturation;
    exports.Noise = Noise;
    exports.blur = index;
    exports.tiltShift = index$1;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9zdHByb2Nlc3NpbmcuanMiLCJzb3VyY2VzIjpbIi4uL3NyYy9ibHVyL2hvcml6b250YWwuanMiLCIuLi9zcmMvYmx1ci92ZXJ0aWNhbC5qcyIsIi4uL3NyYy9ibGVhY2gvaW5kZXguanMiLCIuLi9zcmMvYnJpZ2h0bmVzcy9pbmRleC5qcyIsIi4uL3NyYy9kb3Qtc2NyZWVuL2luZGV4LmpzIiwiLi4vc3JjL3RpbHQtc2hpZnQvaG9yaXpvbnRhbC5qcyIsIi4uL3NyYy90aWx0LXNoaWZ0L3ZlcnRpY2FsLmpzIiwiLi4vc3JjL25vaXNlL2luZGV4LmpzIiwiLi4vc3JjL2h1ZS1zYXR1cmF0aW9uL2luZGV4LmpzIiwiLi4vc3JjL2dsaXRjaC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBIb3Jpem9udGFsID0ge1xuICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIHVfaW5wdXQ6IHsgdHlwZTogJ3NhbXBsZXIyRCcsIHZhbHVlOiBudWxsIH0sXG4gICAgICAgIHVfYW1vdW50OiB7IHR5cGU6ICdmbG9hdCcsIHZhbHVlOiA1MTIgfSxcbiAgICB9LFxuXG4gICAgdmVydGV4OiBgXG4gICAgb3V0IHZlYzIgdl91djtcbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIHZpZXdNYXRyaXggKiBtb2RlbE1hdHJpeCAqIHZlYzQoYV9wb3NpdGlvbiwgMS4wKTtcbiAgICAgICAgdl91diA9IGFfdXY7XG4gICAgfWAsXG5cbiAgICBmcmFnbWVudDogYFxuICAgIGluIHZlYzIgdl91djtcblxuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVfaW5wdXQ7XG4gICAgdW5pZm9ybSBmbG9hdCB1X2Ftb3VudDtcblxuICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgdmVjNCBzdW0gPSB2ZWM0KDAuMCk7XG4gICAgICAgIGZsb2F0IGhoID0gKDEuMCAvIHVfYW1vdW50KTtcblxuICAgICAgICBzdW0gKz0gdGV4dHVyZSh1X2lucHV0LCB2ZWMyKHZfdXYueCAtIDQuMCAqIGhoLCB2X3V2LnkpKSAqIDAuMDUxO1xuICAgICAgICBzdW0gKz0gdGV4dHVyZSh1X2lucHV0LCB2ZWMyKHZfdXYueCAtIDMuMCAqIGhoLCB2X3V2LnkpKSAqIDAuMDkxODtcbiAgICAgICAgc3VtICs9IHRleHR1cmUodV9pbnB1dCwgdmVjMih2X3V2LnggLSAyLjAgKiBoaCwgdl91di55KSkgKiAwLjEyMjQ1O1xuICAgICAgICBzdW0gKz0gdGV4dHVyZSh1X2lucHV0LCB2ZWMyKHZfdXYueCAtIDEuMCAqIGhoLCB2X3V2LnkpKSAqIDAuMTUzMTtcbiAgICAgICAgc3VtICs9IHRleHR1cmUodV9pbnB1dCwgdmVjMih2X3V2LngsIHZfdXYueSApICkgKiAwLjE2MzM7XG4gICAgICAgIHN1bSArPSB0ZXh0dXJlKHVfaW5wdXQsIHZlYzIodl91di54ICsgMS4wICogaGgsIHZfdXYueSkpICogMC4xNTMxO1xuICAgICAgICBzdW0gKz0gdGV4dHVyZSh1X2lucHV0LCB2ZWMyKHZfdXYueCArIDIuMCAqIGhoLCB2X3V2LnkpKSAqIDAuMTIyNDU7XG4gICAgICAgIHN1bSArPSB0ZXh0dXJlKHVfaW5wdXQsIHZlYzIodl91di54ICsgMy4wICogaGgsIHZfdXYueSkpICogMC4wOTE4O1xuICAgICAgICBzdW0gKz0gdGV4dHVyZSh1X2lucHV0LCB2ZWMyKHZfdXYueCArIDQuMCAqIGhoLCB2X3V2LnkpKSAqIDAuMDUxO1xuXG4gICAgICAgIG91dENvbG9yID0gc3VtO1xuICAgIH1gLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgSG9yaXpvbnRhbDtcbiIsImNvbnN0IFZlcnRpY2FsID0ge1xuICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIHVfaW5wdXQ6IHsgdHlwZTogJ3NhbXBsZXIyRCcsIHZhbHVlOiBudWxsIH0sXG4gICAgICAgIHVfYW1vdW50OiB7IHR5cGU6ICdmbG9hdCcsIHZhbHVlOiA1MTIgfSxcbiAgICB9LFxuXG4gICAgdmVydGV4OiBgXG4gICAgb3V0IHZlYzIgdl91djtcbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIHZpZXdNYXRyaXggKiBtb2RlbE1hdHJpeCAqIHZlYzQoYV9wb3NpdGlvbiwgMS4wKTtcbiAgICAgICAgdl91diA9IGFfdXY7XG4gICAgfWAsXG5cbiAgICBmcmFnbWVudDogYFxuICAgIGluIHZlYzIgdl91djtcblxuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVfaW5wdXQ7XG4gICAgdW5pZm9ybSBmbG9hdCB1X2Ftb3VudDtcblxuICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgdmVjNCBzdW0gPSB2ZWM0KDAuMCk7XG4gICAgICAgIGZsb2F0IHZ2ID0gKDEuMCAvIHVfYW1vdW50KTtcblxuICAgICAgICBzdW0gKz0gdGV4dHVyZSh1X2lucHV0LCB2ZWMyKHZfdXYueCwgdl91di55IC0gNC4wICogdnYpKSAqIDAuMDUxO1xuICAgICAgICBzdW0gKz0gdGV4dHVyZSh1X2lucHV0LCB2ZWMyKHZfdXYueCwgdl91di55IC0gMy4wICogdnYpKSAqIDAuMDkxODtcbiAgICAgICAgc3VtICs9IHRleHR1cmUodV9pbnB1dCwgdmVjMih2X3V2LngsIHZfdXYueSAtIDIuMCAqIHZ2KSkgKiAwLjEyMjQ1O1xuICAgICAgICBzdW0gKz0gdGV4dHVyZSh1X2lucHV0LCB2ZWMyKHZfdXYueCwgdl91di55IC0gMS4wICogdnYpKSAqIDAuMTUzMTtcbiAgICAgICAgc3VtICs9IHRleHR1cmUodV9pbnB1dCwgdmVjMih2X3V2LngsIHZfdXYueSApICkgKiAwLjE2MzM7XG4gICAgICAgIHN1bSArPSB0ZXh0dXJlKHVfaW5wdXQsIHZlYzIodl91di54LCB2X3V2LnkgKyAxLjAgKiB2dikpICogMC4xNTMxO1xuICAgICAgICBzdW0gKz0gdGV4dHVyZSh1X2lucHV0LCB2ZWMyKHZfdXYueCwgdl91di55ICsgMi4wICogdnYpKSAqIDAuMTIyNDU7XG4gICAgICAgIHN1bSArPSB0ZXh0dXJlKHVfaW5wdXQsIHZlYzIodl91di54LCB2X3V2LnkgKyAzLjAgKiB2dikpICogMC4wOTE4O1xuICAgICAgICBzdW0gKz0gdGV4dHVyZSh1X2lucHV0LCB2ZWMyKHZfdXYueCwgdl91di55ICsgNC4wICogdnYpKSAqIDAuMDUxO1xuXG4gICAgICAgIG91dENvbG9yID0gc3VtO1xuICAgIH1gLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgVmVydGljYWw7XG4iLCJjb25zdCBCbGVhY2ggPSB7XG4gICAgdW5pZm9ybXM6IHtcbiAgICAgICAgdV9pbnB1dDogeyB0eXBlOiAnc2FtcGxlcjJEJywgdmFsdWU6IG51bGwgfSxcbiAgICAgICAgdV9vcGFjaXR5OiB7IHR5cGU6ICdmbG9hdCcsIHZhbHVlOiAxLjAgfSxcbiAgICB9LFxuXG4gICAgdmVydGV4OiBgXG4gICAgb3V0IHZlYzIgdl91djtcbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIHZpZXdNYXRyaXggKiBtb2RlbE1hdHJpeCAqIHZlYzQoYV9wb3NpdGlvbiwgMS4wKTtcbiAgICAgICAgdl91diA9IGFfdXY7XG4gICAgfWAsXG5cbiAgICBmcmFnbWVudDogYFxuICAgIGluIHZlYzIgdl91djtcblxuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVfaW5wdXQ7XG4gICAgdW5pZm9ybSBmbG9hdCB1X29wYWNpdHk7XG5cbiAgICB2b2lkIG1haW4oKSB7XG5cbiAgICAgICAgdmVjNCBiYXNlID0gdGV4dHVyZSh1X2lucHV0LCB2X3V2KTtcblxuICAgICAgICB2ZWMzIGx1bUNvZWZmID0gdmVjMygwLjI1LCAwLjY1LCAwLjEpO1xuICAgICAgICBmbG9hdCBsdW0gPSBkb3QobHVtQ29lZmYsIGJhc2UucmdiKTtcbiAgICAgICAgdmVjMyBibGVuZCA9IHZlYzMobHVtKTtcblxuICAgICAgICBmbG9hdCBMID0gbWluKDEuMCwgbWF4KDAuMCwgMTAuMCAqIChsdW0gLSAwLjQ1KSkpO1xuXG4gICAgICAgIHZlYzMgcmVzdWx0MSA9IDIuMCAqIGJhc2UucmdiICogYmxlbmQ7XG4gICAgICAgIHZlYzMgcmVzdWx0MiA9IDEuMCAtIDIuMCAqICgxLjAgLSBibGVuZCkgKiAoMS4wIC0gYmFzZS5yZ2IpO1xuXG4gICAgICAgIHZlYzMgbmV3Q29sb3IgPSBtaXgocmVzdWx0MSwgcmVzdWx0MiwgTCk7XG5cbiAgICAgICAgZmxvYXQgQTIgPSB1X29wYWNpdHkgKiBiYXNlLmE7XG4gICAgICAgIHZlYzMgbWl4UkdCID0gQTIgKiBuZXdDb2xvci5yZ2I7XG4gICAgICAgIG1peFJHQiArPSAoKDEuMCAtIEEyKSAqIGJhc2UucmdiKTtcblxuICAgICAgICBvdXRDb2xvciA9IHZlYzQobWl4UkdCLCBiYXNlLmEpO1xuICAgIH1gLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgQmxlYWNoO1xuIiwiY29uc3QgQnJpZ2h0bmVzcyA9IHtcbiAgICB1bmlmb3Jtczoge1xuICAgICAgICB1X2lucHV0OiB7IHR5cGU6ICdzYW1wbGVyMkQnLCB2YWx1ZTogbnVsbCB9LFxuICAgICAgICB1X3RyZXNob2xkOiB7IHR5cGU6ICdmbG9hdCcsIHZhbHVlOiAwLjAgfSxcbiAgICB9LFxuXG4gICAgdmVydGV4OiBgXG4gICAgb3V0IHZlYzIgdl91djtcbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIHZpZXdNYXRyaXggKiBtb2RlbE1hdHJpeCAqIHZlYzQoYV9wb3NpdGlvbiwgMS4wKTtcbiAgICAgICAgdl91diA9IGFfdXY7XG4gICAgfWAsXG5cbiAgICBmcmFnbWVudDogYFxuICAgIGluIHZlYzIgdl91djtcblxuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVfaW5wdXQ7XG4gICAgdW5pZm9ybSBmbG9hdCB1X3RyZXNob2xkO1xuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgICAvLyByZWxhdGl2ZSBsdW1pbmFuY2VcbiAgICAgICAgdmVjMyBsdW0gPSB2ZWMzKDAuMjEyNiwgMC43MTUyLCAwLjA3MjIpO1xuICAgICAgICB2ZWM0IGMgPSB0ZXh0dXJlKHVfaW5wdXQsIHZfdXYpO1xuXG4gICAgICAgIGZsb2F0IGx1bWluYW5jZSA9IGRvdChsdW0sIGMueHl6KTtcbiAgICAgICAgbHVtaW5hbmNlID0gbWF4KDAuMCwgbHVtaW5hbmNlIC0gdV90cmVzaG9sZCk7XG4gICAgICAgIGMueHl6ICo9IHNpZ24obHVtaW5hbmNlKTtcbiAgICAgICAgYy5hID0gMS4wO1xuXG4gICAgICAgIG91dENvbG9yID0gYztcbiAgICB9YCxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEJyaWdodG5lc3M7XG4iLCJjb25zdCBEb3RTY3JlZW4gPSB7XG4gICAgdW5pZm9ybXM6IHtcbiAgICAgICAgdV9pbnB1dDogeyB0eXBlOiAnc2FtcGxlcjJEJywgdmFsdWU6IG51bGwgfSxcbiAgICAgICAgdV9zaXplOiB7IHR5cGU6ICdmbG9hdCcsIHZhbHVlOiAyNTYgfSxcbiAgICAgICAgdV9jZW50ZXI6IHsgdHlwZTogJ3ZlYzInLCB2YWx1ZTogWzAuNSwgMC41XSB9LFxuICAgICAgICB1X2FuZ2xlOiB7IHR5cGU6ICdmbG9hdCcsIHZhbHVlOiAxLjU3IH0sXG4gICAgICAgIHVfc2NhbGU6IHsgdHlwZTogJ2Zsb2F0JywgdmFsdWU6IDEuMCB9LFxuICAgIH0sXG5cbiAgICB2ZXJ0ZXg6IGBcbiAgICBvdXQgdmVjMiB2X3V2O1xuICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogdmlld01hdHJpeCAqIG1vZGVsTWF0cml4ICogdmVjNChhX3Bvc2l0aW9uLCAxLjApO1xuICAgICAgICB2X3V2ID0gYV91djtcbiAgICB9YCxcblxuICAgIGZyYWdtZW50OiBgXG4gICAgaW4gdmVjMiB2X3V2O1xuXG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdV9pbnB1dDtcblxuICAgIHVuaWZvcm0gdmVjMiB1X2NlbnRlcjtcbiAgICB1bmlmb3JtIGZsb2F0IHVfYW5nbGU7XG4gICAgdW5pZm9ybSBmbG9hdCB1X3NjYWxlO1xuICAgIHVuaWZvcm0gZmxvYXQgdV9zaXplO1xuXG4gICAgZmxvYXQgcGF0dGVybigpIHtcbiAgICAgICAgZmxvYXQgcyA9IHNpbih1X2FuZ2xlKSwgYyA9IGNvcyh1X2FuZ2xlKTtcblxuICAgICAgICB2ZWMyIHRleCA9IHZfdXYgKiB2ZWMyKHVfc2l6ZSkgLSB1X2NlbnRlcjtcbiAgICAgICAgdmVjMiBwb2ludCA9IHZlYzIoYyAqIHRleC54IC0gcyAqIHRleC55LCBzICogdGV4LnggKyBjICogdGV4LnkpICogdV9zY2FsZTtcblxuICAgICAgICByZXR1cm4gKHNpbihwb2ludC54KSAqIHNpbihwb2ludC55KSkgKiA0LjA7XG4gICAgfVxuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgICB2ZWM0IGNvbG9yID0gdGV4dHVyZSh1X2lucHV0LCB2X3V2KTtcblxuICAgICAgICBmbG9hdCBhdmVyYWdlID0gKGNvbG9yLnIgKyBjb2xvci5nICsgY29sb3IuYikgLyAzLjA7XG5cbiAgICAgICAgb3V0Q29sb3IgPSB2ZWM0KHZlYzMoYXZlcmFnZSAqIDEwLjAgLSA1LjAgKyBwYXR0ZXJuKCkpLCBjb2xvci5hKTtcbiAgICB9YCxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IERvdFNjcmVlbjtcbiIsImNvbnN0IEhvcml6b250YWwgPSB7XG4gICAgdW5pZm9ybXM6IHtcbiAgICAgICAgdV9pbnB1dDogeyB0eXBlOiAnc2FtcGxlcjJEJywgdmFsdWU6IG51bGwgfSxcbiAgICAgICAgdV9hbW91bnQ6IHsgdHlwZTogJ2Zsb2F0JywgdmFsdWU6IDEyOCB9LFxuICAgICAgICB1X3hzY3JlZW5wb3M6IHsgdHlwZTogJ2Zsb2F0JywgdmFsdWU6IDAuNSB9LFxuICAgIH0sXG5cbiAgICB2ZXJ0ZXg6IGBcbiAgICBvdXQgdmVjMiB2X3V2O1xuICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogdmlld01hdHJpeCAqIG1vZGVsTWF0cml4ICogdmVjNChhX3Bvc2l0aW9uLCAxLjApO1xuICAgICAgICB2X3V2ID0gYV91djtcbiAgICB9YCxcblxuICAgIGZyYWdtZW50OiBgXG4gICAgaW4gdmVjMiB2X3V2O1xuXG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdV9pbnB1dDtcbiAgICB1bmlmb3JtIGZsb2F0IHVfYW1vdW50O1xuICAgIHVuaWZvcm0gZmxvYXQgdV94c2NyZWVucG9zO1xuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgICB2ZWM0IHN1bSA9IHZlYzQoMC4wKTtcbiAgICAgICAgZmxvYXQgaGggPSAoMS4wIC8gdV9hbW91bnQpICogYWJzKHVfeHNjcmVlbnBvcyAtIHZfdXYueCk7XG5cbiAgICAgICAgc3VtICs9IHRleHR1cmUodV9pbnB1dCwgdmVjMih2X3V2LnggLSA0LjAgKiBoaCwgdl91di55KSkgKiAwLjA1MTtcbiAgICAgICAgc3VtICs9IHRleHR1cmUodV9pbnB1dCwgdmVjMih2X3V2LnggLSAzLjAgKiBoaCwgdl91di55KSkgKiAwLjA5MTg7XG4gICAgICAgIHN1bSArPSB0ZXh0dXJlKHVfaW5wdXQsIHZlYzIodl91di54IC0gMi4wICogaGgsIHZfdXYueSkpICogMC4xMjI0NTtcbiAgICAgICAgc3VtICs9IHRleHR1cmUodV9pbnB1dCwgdmVjMih2X3V2LnggLSAxLjAgKiBoaCwgdl91di55KSkgKiAwLjE1MzE7XG4gICAgICAgIHN1bSArPSB0ZXh0dXJlKHVfaW5wdXQsIHZlYzIodl91di54LCB2X3V2LnkgKSApICogMC4xNjMzO1xuICAgICAgICBzdW0gKz0gdGV4dHVyZSh1X2lucHV0LCB2ZWMyKHZfdXYueCArIDEuMCAqIGhoLCB2X3V2LnkpKSAqIDAuMTUzMTtcbiAgICAgICAgc3VtICs9IHRleHR1cmUodV9pbnB1dCwgdmVjMih2X3V2LnggKyAyLjAgKiBoaCwgdl91di55KSkgKiAwLjEyMjQ1O1xuICAgICAgICBzdW0gKz0gdGV4dHVyZSh1X2lucHV0LCB2ZWMyKHZfdXYueCArIDMuMCAqIGhoLCB2X3V2LnkpKSAqIDAuMDkxODtcbiAgICAgICAgc3VtICs9IHRleHR1cmUodV9pbnB1dCwgdmVjMih2X3V2LnggKyA0LjAgKiBoaCwgdl91di55KSkgKiAwLjA1MTtcblxuICAgICAgICBvdXRDb2xvciA9IHN1bTtcbiAgICB9YCxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEhvcml6b250YWw7XG4iLCJjb25zdCBWZXJ0aWNhbCA9IHtcbiAgICB1bmlmb3Jtczoge1xuICAgICAgICB1X2lucHV0OiB7IHR5cGU6ICdzYW1wbGVyMkQnLCB2YWx1ZTogbnVsbCB9LFxuICAgICAgICB1X2Ftb3VudDogeyB0eXBlOiAnZmxvYXQnLCB2YWx1ZTogMTI4IH0sXG4gICAgICAgIHVfeXNjcmVlbnBvczogeyB0eXBlOiAnZmxvYXQnLCB2YWx1ZTogMC41IH0sXG4gICAgfSxcblxuICAgIHZlcnRleDogYFxuICAgIG91dCB2ZWMyIHZfdXY7XG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiB2aWV3TWF0cml4ICogbW9kZWxNYXRyaXggKiB2ZWM0KGFfcG9zaXRpb24sIDEuMCk7XG4gICAgICAgIHZfdXYgPSBhX3V2O1xuICAgIH1gLFxuXG4gICAgZnJhZ21lbnQ6IGBcbiAgICBpbiB2ZWMyIHZfdXY7XG5cbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1X2lucHV0O1xuICAgIHVuaWZvcm0gZmxvYXQgdV9hbW91bnQ7XG4gICAgdW5pZm9ybSBmbG9hdCB1X3lzY3JlZW5wb3M7XG5cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIHZlYzQgc3VtID0gdmVjNCgwLjApO1xuICAgICAgICBmbG9hdCB2diA9ICgxLjAgLyB1X2Ftb3VudCkgKiBhYnModV95c2NyZWVucG9zIC0gdl91di55KTtcblxuICAgICAgICBzdW0gKz0gdGV4dHVyZSh1X2lucHV0LCB2ZWMyKHZfdXYueCwgdl91di55IC0gNC4wICogdnYpKSAqIDAuMDUxO1xuICAgICAgICBzdW0gKz0gdGV4dHVyZSh1X2lucHV0LCB2ZWMyKHZfdXYueCwgdl91di55IC0gMy4wICogdnYpKSAqIDAuMDkxODtcbiAgICAgICAgc3VtICs9IHRleHR1cmUodV9pbnB1dCwgdmVjMih2X3V2LngsIHZfdXYueSAtIDIuMCAqIHZ2KSkgKiAwLjEyMjQ1O1xuICAgICAgICBzdW0gKz0gdGV4dHVyZSh1X2lucHV0LCB2ZWMyKHZfdXYueCwgdl91di55IC0gMS4wICogdnYpKSAqIDAuMTUzMTtcbiAgICAgICAgc3VtICs9IHRleHR1cmUodV9pbnB1dCwgdmVjMih2X3V2LngsIHZfdXYueSApICkgKiAwLjE2MzM7XG4gICAgICAgIHN1bSArPSB0ZXh0dXJlKHVfaW5wdXQsIHZlYzIodl91di54LCB2X3V2LnkgKyAxLjAgKiB2dikpICogMC4xNTMxO1xuICAgICAgICBzdW0gKz0gdGV4dHVyZSh1X2lucHV0LCB2ZWMyKHZfdXYueCwgdl91di55ICsgMi4wICogdnYpKSAqIDAuMTIyNDU7XG4gICAgICAgIHN1bSArPSB0ZXh0dXJlKHVfaW5wdXQsIHZlYzIodl91di54LCB2X3V2LnkgKyAzLjAgKiB2dikpICogMC4wOTE4O1xuICAgICAgICBzdW0gKz0gdGV4dHVyZSh1X2lucHV0LCB2ZWMyKHZfdXYueCwgdl91di55ICsgNC4wICogdnYpKSAqIDAuMDUxO1xuXG4gICAgICAgIG91dENvbG9yID0gc3VtO1xuICAgIH1gLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgVmVydGljYWw7XG4iLCJjb25zdCBOb2lzZSA9IHtcbiAgICB1bmlmb3Jtczoge1xuICAgICAgICB1X2lucHV0OiB7IHR5cGU6ICdzYW1wbGVyMkQnLCB2YWx1ZTogbnVsbCB9LFxuICAgICAgICB1X3NlZWQ6IHsgdHlwZTogJ2Zsb2F0JywgdmFsdWU6IDAuMDEgfSxcbiAgICAgICAgdV9hbW91bnQ6IHsgdHlwZTogJ2Zsb2F0JywgdmFsdWU6IDAuNSB9LFxuICAgIH0sXG5cbiAgICB2ZXJ0ZXg6IGBcbiAgICBvdXQgdmVjMiB2X3V2O1xuICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogdmlld01hdHJpeCAqIG1vZGVsTWF0cml4ICogdmVjNChhX3Bvc2l0aW9uLCAxLjApO1xuICAgICAgICB2X3V2ID0gYV91djtcbiAgICB9YCxcblxuICAgIGZyYWdtZW50OiBgXG4gICAgaW4gdmVjMiB2X3V2O1xuXG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdV9pbnB1dDtcbiAgICB1bmlmb3JtIGZsb2F0IHVfc2VlZDtcbiAgICB1bmlmb3JtIGZsb2F0IHVfYW1vdW50O1xuXG4gICAgZmxvYXQgcmFuZCh2ZWMyIHV2KSB7XG4gICAgICAgIHJldHVybiBmcmFjdChzaW4oZG90KHV2Lnh5LCB2ZWMyKDEyLjk4OTgsIDc4LjIzMykpKSAqIDQzNzU4LjU0NTMpO1xuICAgIH1cblxuICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgdmVjNCBjb2xvciA9IHRleHR1cmUodV9pbnB1dCwgdl91dik7XG4gICAgICAgIGZsb2F0IHJhbmRvbSA9IHJhbmQoZ2xfRnJhZ0Nvb3JkLnh5ICogdV9zZWVkKTtcbiAgICAgICAgZmxvYXQgZGlmZiA9IChyYW5kb20gLSAwLjUpICogdV9hbW91bnQ7XG5cbiAgICAgICAgY29sb3IuciArPSBkaWZmO1xuICAgICAgICBjb2xvci5nICs9IGRpZmY7XG4gICAgICAgIGNvbG9yLmIgKz0gZGlmZjtcblxuICAgICAgICBvdXRDb2xvciA9IGNvbG9yO1xuICAgIH1gLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgTm9pc2U7XG4iLCJjb25zdCBIdWVTYXR1cmF0aW9uID0ge1xuICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIHVfaW5wdXQ6IHsgdHlwZTogJ3NhbXBsZXIyRCcsIHZhbHVlOiBudWxsIH0sXG4gICAgICAgIHVfaHVlOiB7IHR5cGU6ICdmbG9hdCcsIHZhbHVlOiAwLjAgfSwgLy8gLTEgdG8gMVxuICAgICAgICB1X3NhdHVyYXRpb246IHsgdHlwZTogJ2Zsb2F0JywgdmFsdWU6IDAuMCB9LCAvLyAtMSB0byAxXG4gICAgfSxcblxuICAgIHZlcnRleDogYFxuICAgIG91dCB2ZWMyIHZfdXY7XG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiB2aWV3TWF0cml4ICogbW9kZWxNYXRyaXggKiB2ZWM0KGFfcG9zaXRpb24sIDEuMCk7XG4gICAgICAgIHZfdXYgPSBhX3V2O1xuICAgIH1gLFxuXG4gICAgZnJhZ21lbnQ6IGBcbiAgICBpbiB2ZWMyIHZfdXY7XG5cbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1X2lucHV0O1xuICAgIHVuaWZvcm0gZmxvYXQgdV9odWU7XG4gICAgdW5pZm9ybSBmbG9hdCB1X3NhdHVyYXRpb247XG5cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIHZlYzQgY29sb3IgPSB0ZXh0dXJlKHVfaW5wdXQsIHZfdXYpO1xuICAgICAgICBmbG9hdCBhbmdsZSA9IHVfaHVlICogMy4xNDE1OTI2NTtcbiAgICAgICAgZmxvYXQgcyA9IHNpbihhbmdsZSksIGMgPSBjb3MoYW5nbGUpO1xuICAgICAgICB2ZWMzIHdlaWdodHMgPSAodmVjMygyLjAgKiBjLCAtc3FydCgzLjApICogcyAtIGMsIHNxcnQoMy4wKSAqIHMgLSBjKSArIDEuMCkgLyAzLjA7XG4gICAgICAgIGZsb2F0IGxlbiA9IGxlbmd0aChjb2xvci5yZ2IpO1xuICAgICAgICBjb2xvci5yZ2IgPSB2ZWMzKFxuICAgICAgICAgICAgZG90KGNvbG9yLnJnYiwgd2VpZ2h0cy54eXopLFxuICAgICAgICAgICAgZG90KGNvbG9yLnJnYiwgd2VpZ2h0cy56eHkpLFxuICAgICAgICAgICAgZG90KGNvbG9yLnJnYiwgd2VpZ2h0cy55engpXG4gICAgICAgICk7XG5cbiAgICAgICAgZmxvYXQgYXZlcmFnZSA9IChjb2xvci5yICsgY29sb3IuZyArIGNvbG9yLmIpIC8gMy4wO1xuICAgICAgICBpZiAodV9zYXR1cmF0aW9uID4gMC4wKSB7XG4gICAgICAgICAgICBjb2xvci5yZ2IgKz0gKGF2ZXJhZ2UgLSBjb2xvci5yZ2IpICogKDEuMCAtIDEuMCAvICgxLjAwMSAtIHVfc2F0dXJhdGlvbikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29sb3IucmdiICs9IChhdmVyYWdlIC0gY29sb3IucmdiKSAqICgtdV9zYXR1cmF0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG91dENvbG9yID0gY29sb3I7XG4gICAgfWAsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBIdWVTYXR1cmF0aW9uO1xuIiwiLy8gaW5zcGlyZWQgYnk6IGh0dHBzOi8vd3d3LnNoYWRlcnRveS5jb20vdmlldy80dDIzUmNcbmNvbnN0IEdsaXRjaCA9IHtcbiAgICB1bmlmb3Jtczoge1xuICAgICAgICB1X2lucHV0OiB7IHR5cGU6ICdzYW1wbGVyMkQnLCB2YWx1ZTogbnVsbCB9LFxuICAgICAgICB1X2FtcGxpdHVkZTogeyB0eXBlOiAnZmxvYXQnLCB2YWx1ZTogMy4wIH0sXG4gICAgICAgIHVfc3BlZWQ6IHsgdHlwZTogJ2Zsb2F0JywgdmFsdWU6IDIuMCB9LFxuICAgIH0sXG5cbiAgICB2ZXJ0ZXg6IGBcbiAgICBvdXQgdmVjMiB2X3V2O1xuICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogdmlld01hdHJpeCAqIG1vZGVsTWF0cml4ICogdmVjNChhX3Bvc2l0aW9uLCAxLjApO1xuICAgICAgICB2X3V2ID0gYV91djtcbiAgICB9YCxcblxuICAgIGZyYWdtZW50OiBgXG4gICAgaW4gdmVjMiB2X3V2O1xuXG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdV9pbnB1dDtcbiAgICB1bmlmb3JtIGZsb2F0IHVfc3BlZWQ7XG4gICAgdW5pZm9ybSBmbG9hdCB1X2FtcGxpdHVkZTtcblxuICAgIHZlYzQgcmdiU2hpZnQodmVjMiBwLCB2ZWM0IHNoaWZ0KSB7XG4gICAgICAgIHNoaWZ0ICo9IDIuMCAqIHNoaWZ0LncgLSAxLjA7XG4gICAgICAgIHZlYzIgcnMgPSB2ZWMyKHNoaWZ0LngsIC1zaGlmdC55KTtcbiAgICAgICAgdmVjMiBncyA9IHZlYzIoc2hpZnQueSwgLXNoaWZ0LnopO1xuICAgICAgICB2ZWMyIGJzID0gdmVjMihzaGlmdC56LCAtc2hpZnQueCk7XG5cbiAgICAgICAgZmxvYXQgciA9IHRleHR1cmUodV9pbnB1dCwgcCArIHJzKS54O1xuICAgICAgICBmbG9hdCBnID0gdGV4dHVyZSh1X2lucHV0LCBwICsgZ3MpLnk7XG4gICAgICAgIGZsb2F0IGIgPSB0ZXh0dXJlKHVfaW5wdXQsIHAgKyBicykuejtcblxuICAgICAgICByZXR1cm4gdmVjNChyLCBnLCBiLCAxLjApO1xuICAgIH1cblxuICAgIGZsb2F0IHJhbmQodmVjMiB1dikge1xuICAgICAgICByZXR1cm4gZnJhY3Qoc2luKGRvdCh1di54eSwgdmVjMigxMi45ODk4LCA3OC4yMzMpKSkgKiA0Mzc1OC41NDUzKTtcbiAgICB9XG5cbiAgICB2ZWM0IG5vaXNlKHZlYzIgbikge1xuICAgICAgICBmbG9hdCByID0gcmFuZChuLnh5ICsgMC4xKTtcbiAgICAgICAgZmxvYXQgZyA9IHJhbmQobi54eSArIDAuMik7XG4gICAgICAgIGZsb2F0IGIgPSByYW5kKG4ueHkgKyAwLjMpO1xuICAgICAgICByZXR1cm4gdmVjNChyIC0gMC41LCBnIC0gMC41LCBiIC0gMC41LCAxLjApO1xuICAgIH1cblxuICAgIHZlYzQgdmVjNHBvdyh2ZWM0IHYsIGZsb2F0IHApIHtcbiAgICAgICAgcmV0dXJuIHZlYzQocG93KHYueCwgcCksIHBvdyh2LnksIHApLCBwb3codi56LCBwKSwgdi53KTtcbiAgICB9XG5cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIHZlYzQgY29sb3IgPSB0ZXh0dXJlKHVfaW5wdXQsIHZfdXYpO1xuXG4gICAgICAgIHZlYzQgYyA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMS4wKTtcblxuICAgICAgICBmbG9hdCB2ID0gY2xhbXAoc2luKGlHbG9iYWxUaW1lICogdV9zcGVlZCksIDAuMCwgMS4wKTtcbiAgICAgICAgdmVjNCBzaGlmdCA9IHZlYzRwb3cobm9pc2UodmVjMigxLjAgLSB2LCAwLjApKSwgOC4wKSAqIHZlYzQodV9hbXBsaXR1ZGUsIHVfYW1wbGl0dWRlLCB1X2FtcGxpdHVkZSwgMS4wKSAqIHY7XG5cbiAgICAgICAgYyArPSByZ2JTaGlmdCh2X3V2LCBzaGlmdCk7XG5cbiAgICAgICAgb3V0Q29sb3IgPSBjO1xuICAgIH1gLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgR2xpdGNoO1xuIl0sIm5hbWVzIjpbIkhvcml6b250YWwiLCJ1bmlmb3JtcyIsInVfaW5wdXQiLCJ0eXBlIiwidmFsdWUiLCJ1X2Ftb3VudCIsInZlcnRleCIsImZyYWdtZW50IiwiVmVydGljYWwiLCJCbGVhY2giLCJ1X29wYWNpdHkiLCJCcmlnaHRuZXNzIiwidV90cmVzaG9sZCIsIkRvdFNjcmVlbiIsInVfc2l6ZSIsInVfY2VudGVyIiwidV9hbmdsZSIsInVfc2NhbGUiLCJ1X3hzY3JlZW5wb3MiLCJ1X3lzY3JlZW5wb3MiLCJOb2lzZSIsInVfc2VlZCIsIkh1ZVNhdHVyYXRpb24iLCJ1X2h1ZSIsInVfc2F0dXJhdGlvbiIsIkdsaXRjaCIsInVfYW1wbGl0dWRlIiwidV9zcGVlZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0lBQUEsSUFBTUEsYUFBYTtJQUNmQyxjQUFVO0lBQ05DLGlCQUFTLEVBQUVDLE1BQU0sV0FBUixFQUFxQkMsT0FBTyxJQUE1QixFQURIO0lBRU5DLGtCQUFVLEVBQUVGLE1BQU0sT0FBUixFQUFpQkMsT0FBTyxHQUF4QjtJQUZKLEtBREs7O0lBTWZFLDhLQU5lOztJQWFmQztJQWJlLENBQW5COztJQ0FBLElBQU1DLFdBQVc7SUFDYlAsY0FBVTtJQUNOQyxpQkFBUyxFQUFFQyxNQUFNLFdBQVIsRUFBcUJDLE9BQU8sSUFBNUIsRUFESDtJQUVOQyxrQkFBVSxFQUFFRixNQUFNLE9BQVIsRUFBaUJDLE9BQU8sR0FBeEI7SUFGSixLQURHOztJQU1iRSw4S0FOYTs7SUFhYkM7SUFiYSxDQUFqQjs7Ozs7Ozs7O0lD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
